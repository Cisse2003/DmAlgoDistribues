# algorithme de detection de terminaison de Kumar
# parametre optionnel: nombre de noeuds

import sys, random
config(channel is fifo)

class Agent(process):

    # ags: liste des identifiants DistAlgo des agents
    # mon: identifiant DistAlgo du moniteur
    def setup(ags, mon):
        self.aSent = dict.fromkeys(ags, 0)
        self.aRcvd = dict.fromkeys(ags, 0)
        self.active = True 

    def run():
        # Pour simuler l'exécution continue
        while True:
            # Transitions sontanées (seulement si actif)
            if self.active:
                r = random.random()
                if r < 0.2:
                    # Envoi d'un message 'm' à un agent aléatoire ( y compris soi-même)
                    q = random.choice(ags)
                    self.aSent[q] += 1
                    send(('m', self), to=q)
                    output(f"Agent envoie m à {q}")
                elif r < 0.3:
                    # Terminaison locale
                    self.active = False
                    send(('t', dict(self.aSent), dict(self.aRcvd)), to=mon)
                    output("Agent devient inactif et envoie t au moniteur")

            # Syntaxe await simplifiée pour éviter les SyntaxError précédentes
            if await(some(received(('stop',)))):
                break
            elif timeout(0.1):
                pass
        
        output("Arrêt de l'agent.")

    def receive(msg=('m', q)):
        self.active = True # [cite: 44]
        self.aRcvd[q] += 1 # [cite: 45]
        output(f"Reçu m de {q}")

class Monitor(process):
    def setup(ags):
        self.seen = set()
        self.mSent = {p: dict.fromkeys(ags, 0) for p in ags}
        self.mRcvd = {p: dict.fromkeys(ags, 0) for p in ags}

    def run():
        output("Moniteur : Initialisé. En attente de détection...")

        # Condition de terminaison globale
            # tous inactifs
            # plus de messages dans le réseau

        await(len(self.seen) == len(self.ags) and
              all(self.mSent[p][q] == self.mRcvd[q][p] for p in self.ags for q in self.ags))

        output(">>> MONITEUR : TERMINAISON GLOBALE DÉTECTÉE <<<")
        send(('done',), to=parent())

        await(some(received(('stop',))))
        output("Moniteur : Arrêt.")

    def receive(msg=('t', s, r), from_=p):
        self.seen.add(p)
        self.mSent[p] = s
        self.mRcvd[p] = r
        output(f"Moniteur : t reçu de {p}. ({len(self.seen)}/{len(self.ags)})")

def main():
    n = int(sys.argv[1]) if len(sys.argv) > 1 else 5
    # creer une liste plutot qu'un ensemble d'agents simplifie l'initialisation des compteurs
    ags = list(new(Agent, num = n))
    monitor = new(Monitor)
    for a in ags:
        setup(a, (ags, monitor))
    setup(monitor, (ags,))

    start(monitor)
    start(ags)

    # perso: Le main doit attendre que le moniteur ait fini 
    if await(some(received(('done',)))):
        output("Main a reçu 'done' du moniteur, envoi de 'stop' à tous les agents et moniteur.")
        send(('stop',), to=(ags + [monitor]))