# algorithme de detection de terminaison de Kumar
# parametre optionnel: nombre de noeuds

import sys, random
config(channel is fifo)


class Agent(process):

    # ags : liste des agents du système
    # mon : identifiant du moniteur
    def setup(ags, mon):
        # mémorisation des autres agents et du moniteur
        self.ags = ags
        self.mon = mon

        self.aSent = dict.fromkeys(ags, 0)
        self.aRcvd = dict.fromkeys(ags, 0)
        self.active = True 

    def run():
        # exécution continue de l'agent, boucle inf
        while True:

            # transitions spontanées possibles uniquement si l'agent est actif
            if self.active:
                r = random.random()

                if r < 0.5:
                    # envoi d'un message applicatif 'm' à un agent q
                    q = random.choice(self.ags)
                    send('m', to=q)
                    self.aSent[q] += 1
                    output(f"Agent {self.pid} envoie m à {q}")

                else:
                    # terminaison locale :
                    # l'agent devient inactif et informe le moniteur
                    self.active = False
                    t_msg = ('t', dict(self.aSent), dict(self.aRcvd))
                    send(t_msg, to=self.mon)
                    output(f"Agent {self.pid} devient inactif et envoie t")

            await receive()

    # réception d'un message applicatif 'm'
    receive('m', q):
        self.active = True
        self.aRcvd[q] += 1
        output(f"Agent {self.pid} reçoit m de {q}")


class Monitor(process):

    # a completer 

def main():
    n = int(sys.argv[1]) if len(sys.argv) > 1 else 5
    # creer une liste plutot qu'un ensemble d'agents simplifie l'initialisation des compteurs
    ags = list(new(Agent, num = n))
    monitor = new(Monitor)
    for a in ags:
        setup(a, (ags, monitor))
    setup(monitor, (ags,))

    start(monitor)
    start(ags)
