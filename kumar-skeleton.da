# algorithme de detection de terminaison de Kumar
# parametre optionnel: nombre de noeuds

import sys, random
config(channel is fifo)


class Agent(process):
    def setup(ags, mon):
        self.ags = ags
        self.mon = mon
        self.aSent = dict.fromkeys(ags, 0)
        self.aRcvd = dict.fromkeys(ags, 0)
        self.active = True 

    def run():
    
        while True:
            if self.active:
                r = random.random()
                if r < 0.5:
                    # On exclut soi-même pour éviter les boucles infinies sur un seul agent
                    q = random.choice([a for a in self.ags if a != self])
                    send(('m',), to=q) # Utilise un tuple ('m',) c'est plus sûr
                    self.aSent[q] += 1
                    output(f"Agent {self.pid} envoie m à {q}")
                else:
                    self.active = False
                    # On envoie des copies (dict) pour éviter les accès concurrents
                    send(('t', dict(self.aSent), dict(self.aRcvd)), to=self.mon)
                    output(f"Agent {self.pid} devient inactif et envoie t")

            # await receive() est bloquant.
            # Pour Kumar, il vaut mieux attendre une condition ou un timeout
            if await(some(received(('stop',)))):
                break
            elif not self.active:
                # Si inactif, on attend d'être réveillé ou de devoir s'arrêter
                await(self.active or some(received(('stop',))), timeout=0.1)

    def receive(msg=('m',), from_=q):
        self.active = True
        self.aRcvd[q] += 1
        output(f"Agent {self.pid} reçoit m de {q}")


class Monitor(process):

    # a completer 

def main():
    n = int(sys.argv[1]) if len(sys.argv) > 1 else 5
    # creer une liste plutot qu'un ensemble d'agents simplifie l'initialisation des compteurs
    ags = list(new(Agent, num = n))
    monitor = new(Monitor)
    for a in ags:
        setup(a, (ags, monitor))
    setup(monitor, (ags,))

    start(monitor)
    start(ags)
