# algorithme de detection de terminaison de Kumar
# parametre optionnel: nombre de noeuds

import sys, random
config(channel is fifo)

class Agent(process):

    # ags: liste des identifiants DistAlgo des agents
    # mon: identifiant DistAlgo du moniteur
    def setup(ags, mon):
        self.aSent = dict.fromkeys(ags, 0)
        self.aRcvd = dict.fromkeys(ags, 0)
        self.active = True

    def run():
        # Boucle infinie pour simuler l'exécution continue
        while True:
            # Transitions spontanées (seulement si actif)
            if self.active:
                r = random.random()
                if r < 0.5:
                    # Envoi d'un message 'm' à un agent aléatoire ( y compris soi-même)
                    q = random.choice(self.ags)
                    send('m', to=q)
                    self.aSent[q] += 1
                    print(f"Agent {self.pid} a envoyé 'm' à {q}, aSent[{q}] = {self.aSent[q]}")
                else:
                # Terminaison locale
                self.active = False
                t_msg = ('t', dict(self.aSent), dict(self.aRcvd))
                send(t_msg, to=self.mon)
                print(f"Agent {self.pid} terminaison locale, envoyé {t_msg} au moniteur")
            # Réception du prochain message (bloque jusqu'à arrivée)
            msg, sender = receive()
            if msg == 'stop':
                print(f"Agent {self.pid} a reçu 'stop', sortie")
                break
            elif msg == 'm' and sender in self.aRcvd:
                self.active = True
                self.aRcvd[sender] += 1
                print(f"Agent {self.pid} a reçu 'm' de {sender}, active=True, aRcvd[{sender}] = {self.aRcvd[sender]}")"
            else:
                print(f"Agent {self.pid} message inattendu {msg} de {sender}")

class Monitor(process):

    def setup(ags):
        self.ags = ags
        self.n = len(ags)
        self.seen = set()
        self.mSent = {p: dict.fromkeys(ags, 0) for p in ags}
        self.mRcvd = {p: dict.fromkeys(ags, 0) for p in ags}

    def run():
        # Boucle infinie pour réception continue
        while True:
            msg, sender = receive()
            if msg == 'stop':
                print("Moniteur a reçu 'stop', sortie")
                break
            elif isinstance(msg, tuple) and msg[0] == 't':
                p = sender
                _, s, r = msg
                self.seen.add(p)
                self.mSent[p] = s.copy()
                self.mRcvd[p] = r.copy()
                print(f"Moniteur a reçu 't' de {p}, seen={self.seen}")

                # Vérification de la terminaison globale
                if len(self.seen) == self.n:
                    terminer = True
                    for pi in self.ags:
                        for qi in self.ags:
                            if self.mSent[pi][qi] != self.mRcvd[qi][pi]:
                                termner = False
                                break
                        if not terminer:
                            break
                    if terminer:
                        print("Moniteur : TERMINAISON GLOBALE DÉTECTÉE !!")
                        send('done', to=parent())
                        #Continuer pour attendre 'stop' du main
            else:
                print(f"Moniteur message inattendu {msg} de {sender}")



def main():
    n = int(sys.argv[1]) if len(sys.argv) > 1 else 5
    # creer une liste plutot qu'un ensemble d'agents simplifie l'initialisation des compteurs
    ags = list(new(Agent, num = n))
    monitor = new(Monitor)
    for a in ags:
        setup(a, (ags, monitor))
    setup(monitor, (ags,))

    start(monitor)
    start(ags)

    # Le main attend 'done' du moniteur
    msg, sender = receive()
    if msg == 'done':
        print("Main a reçu 'done' du moniteur, envoi de 'stop' à tous les agents et moniteur")
        for a in ags:
            send('stop', to=a)
        send('stop', to=moniteur)
    else:
        pirnt(f"Main message inattendu {msg} de {sender}")
